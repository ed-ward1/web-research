package uk.co.whatsa.research.presentation;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Locale;

import org.slf4j.Logger;

import uk.co.whatsa.research.ResearchRuntimeException;

/**
 * A presentation tier helper class containing static methods used by
 * the {@link CaptureWebPage} class.
 */
public final class CaptureHelper {

    /**
     * The name given to resources when the URL did not contain a
     * name.
     */
    private static final String DEFAULT_FILENAME = "index.html";

    /**
     * The value used to indicate End Of Stream when reading bytes
     * from a stream.
     */
    private static final int EOS = -1;

    /**
     * This is a helper class and should not be instantiated.
     */
    private CaptureHelper() {
    }

    /**
     * The path should always equal the path of the
     * {@link #mainResource}. This method is needed to find the
     * {@link #mainResource} before the property has been set.
     * 
     * @param webPageUrl the URL provided when capturing the web page
     * @return The path of the resource associated with this web
     *         page's main html file or {@code null} if there is an
     *         error.
     */
    static String getResourcePath(final String webPageUrl) {
        // Remove the preceding protocol and domain
        final int notFound = -1;
        int slashOffset = 0;

        for (int i = 0; i < 2 && slashOffset != notFound; i++, slashOffset++) {
            slashOffset = webPageUrl.indexOf('/', slashOffset);
        }
        String resourcePath = null;
        if (slashOffset == notFound) {
            resourcePath = DEFAULT_FILENAME;
        } else {
            resourcePath = webPageUrl.substring(slashOffset);

            int end = resourcePath.length();
            final int hashOffset = resourcePath.indexOf('#');
            if (hashOffset != notFound) {
                end = hashOffset;
            }
            final int queryOffset = resourcePath.indexOf('?');
            if (queryOffset != notFound && queryOffset < end) {
                end = queryOffset;
            }
            resourcePath = resourcePath.substring(0, end);
            if (resourcePath.endsWith("/") || resourcePath.length() == 0) {
                resourcePath = new StringBuilder(resourcePath).append(DEFAULT_FILENAME).toString();
            }
        }

        return resourcePath;
    }

    /**
     * If the URL does not contain a reference to a filename then the
     * default (index.html) is returned.
     * 
     * @param filename the resource / filename possibly with trailing
     *            parameters.
     * @return the filename (resource name) portion of a partial URL.
     */
    static String getFilenameWithoutParameters(final String filename) {
        String filenameWithoutParameters = stripParameters(filename);
        final int characterNotFound = -1;
        if (filenameWithoutParameters.indexOf('.') == characterNotFound) {
            filenameWithoutParameters = DEFAULT_FILENAME;
        }
        return filenameWithoutParameters;
    }

    /**
     * @param withParameters a partial URL string possibly containing
     *            parameter after the resource name
     * @return the input string stripped of any trailing parameters
     *         (after the ? or #)
     */
    static String stripParameters(final String withParameters) {
        final int firstQuestionMark = withParameters.indexOf('?');
        final int firstHashMark = withParameters.indexOf('#');

        final int notFound = -1;

        int end = withParameters.length();
        if (firstQuestionMark != notFound) {
            end = firstQuestionMark;
        }
        if (firstHashMark != notFound && firstHashMark < end) {
            end = firstHashMark;
        }
        return withParameters.substring(0, end);
    }

    /**
     * @param rootFolder the root folder in which wget created the
     *            resources
     * @param file the path of the file generated by wget
     * @return a relative resource path based on the file path of the
     *         resource object created by wget.
     */
    static String getResourcePath(final File rootFolder, final File file) {
        final String rootFolderPath = rootFolder.getPath();
        final String filepath = file.getPath();
        if (rootFolderPath.length() > filepath.length()) {
            final Logger log = CaptureWebPage.getLogger();
            if (log.isErrorEnabled()) {
                log.error("resource root folder path was longer than the resource path", rootFolderPath);
            }
            return filepath;
        }
        return filepath.substring(rootFolderPath.length() + 1, filepath.length());
    }

    /**
     * @param file the resource file to be read
     * @param buffer a buffer used to hold the resource data
     * @return the contents of the resource file as one very long byte
     *         array
     */
    static byte[] readResourceData(final File file, final byte[] buffer) {
        final Logger log = CaptureWebPage.getLogger();
        if (log.isDebugEnabled()) {
            log.debug("reading resource data from file: " + file.getPath());
        }
        byte[] resourceData = null;
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            int bytesRead = fis.read(buffer);
            final ByteArrayOutputStream baos = new ByteArrayOutputStream((int) file.length());
            while (bytesRead != EOS) {
                baos.write(buffer, 0, bytesRead);
                bytesRead = fis.read(buffer);
            }
            resourceData = baos.toByteArray();
        } catch (IOException e) {
            throw new ResearchRuntimeException(e);
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    log.error(e.getMessage());
                }
            }
        }
        return resourceData;
    }

    /**
     * The wget page download may have retrieved resources from
     * domains that are of no interest. For example, retrieving a page
     * from {@code www.dailymail.co.uk} will download resources from
     * all of the following domains. We are only interested in the
     * ones ending "{@code dailymail.co.uk}"
     * 
     * <pre>
     * admin.brightcove.com
     * cdn.taboola.com
     * dailymail.co.uk
     * f.dailymail.co.uk
     * f.mol.im
     * i.dailymail.co.uk
     * i.mol.im
     * pagead2.googlesyndication.com
     * rta.dailymail.co.uk
     * scripts.dailymail.co.uk
     * tags.crwdcntrl.net
     * www.dailymail.co.uk
     * www.facebook.com
     * </pre>
     * 
     * This method will delete all folders that are not subdomains of
     * the domain associated with the downloaded web page.
     * 
     * TODO this method needs tidying up
     * 
     * @param domainsFolder the folder containing the downloaded web
     *            page resources
     * @param domainName the domain name of the page that was
     *            downloaded
     */
    static void deleteUnwantedFolders(final File domainsFolder, final String domainName) {
        final String wwwPrefix = "www.";

        final String dotCom = ".com";
        final String dotNet = ".net";
        final String dotOrg = ".org";
        final String dotGov = ".gov";
        final char fullstop = '.';

        String modifiedDomainName = domainName;

        if (modifiedDomainName.startsWith(wwwPrefix)) {
            modifiedDomainName = modifiedDomainName.substring(wwwPrefix.length());
        }
        int dotCount;
        if (modifiedDomainName.endsWith(dotCom) || modifiedDomainName.endsWith(dotNet)
                || modifiedDomainName.endsWith(dotOrg) || modifiedDomainName.endsWith(dotGov)) {
            dotCount = 1;
        } else {
            dotCount = 2;
        }
        for (int i = modifiedDomainName.length() - 1; i >= 0; i--) {
            if (modifiedDomainName.charAt(i) == fullstop) {
                dotCount--;
                if (dotCount < 0) {
                    modifiedDomainName = modifiedDomainName.substring(i + 1);
                    break;
                }
            }
        }

        modifiedDomainName = modifiedDomainName.toLowerCase(Locale.getDefault());

        for (final File file : domainsFolder.listFiles()) {
            if (!file.isDirectory()) {
                continue;
            }
            if (!file.getName().toLowerCase().endsWith(modifiedDomainName)) {
                deleteFolder(file);
            }
        }
    }

    /**
     * Deletes a folder by individually deleting each file and
     * subfolder folder.
     * 
     * @param folder the folder to be deleted
     * @return true of the folder was deleted successfully
     */
    static boolean deleteFolder(final File folder) {
        boolean success = false;
        if (folder.isDirectory()) {
            for (final File file : folder.listFiles()) {
                if (file.isDirectory()) {
                    deleteFolder(file);
                } else {
                    file.delete();
                }
            }
            success = folder.delete();
        }

        return success;
    }
}
